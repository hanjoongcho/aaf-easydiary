# [ADR-0001] 디바이스 로컬 저장소로 Realm 채택

## 상태 (Status)

승인됨 (Accepted)

## 컨텍스트 (Context)

이지다이어리(EasyDiary) 서비스는 일기 본문, 사진 경로, 위치 정보 등 복잡한 관계를 가진 데이터를 로컬에 저장하고 빠르게 조회해야 합니다. 기존 안드로이드의 SQLite나 Room 라이브러리는 관계형 데이터 모델(RDBMS) 기반이라 객체 지향 언어인 Kotlin/Java와 모델 간의 간극(Impedance Mismatch)이 존재하며, 복잡한 쿼리 작성 시 유지보수 비용이 발생합니다.

## 결정 (Decision)

우리는 로컬 데이터베이스로 **Realm(NoSQL Object Database)**을 채택한다. 이 결정은 아래의 라이브러리 비교 및 기술적 이점을 바탕으로 한다.

| 비교 항목 | Realm | Room (SQLite) |
| --- | --- | --- |
| **모델 구조** | 객체 지향 (객체 그대로 저장) | 관계형 (테이블 매핑 필요) |
| **성능** | 객체 직렬화가 없어 매우 빠름 | SQL 파싱 및 커서 변환으로 상대적으로 느림 |
| **관계 표현** | `RealmList`, 직접 참조 (간결함) | 외래 키, Join, `@Relation` (복잡함) |
| **반응형 UI** | Live Objects (데이터 변경 시 자동 갱신) | LiveData/Flow 연동 설정 필요 |
| **러닝 커브** | 낮음 (객체 다루듯 사용) | 중간 (SQL 지식 필수) |

### 선택 사유 (Rationales)

1. **객체 중심 설계:** `Diary` 모델은 `PhotoUri`, `Location` 등 하위 객체를 포함하며 다른 일기와 연결(`linkedDiaries`)되는 구조입니다. Realm은 이를 별도의 Join 쿼리 없이 객체 그래프 형태로 직렬화 없이 저장하고 가져올 수 있어 개발 생산성이 높습니다.
2. **복잡한 데이터 관계 처리:** `RealmList<PhotoUri>`와 같은 리스트 구조를 별도의 중간 테이블 없이 즉시 처리할 수 있어 일기 데이터의 무결성 관리가 용이합니다.
3. **Lazy Loading 성능:** 일기 목록이 수천 개가 되어도 Realm은 필요한 시점에 데이터를 로드하므로, 메모리 점유율을 낮게 유지하면서 빠른 스크롤 성능을 제공합니다.
4. **암호화 지원:** 모델에 정의된 `isEncrypt` 정책과 결합하여, Realm 자체에서 제공하는 투명한 DB 암호화 기능을 활용하기에 적합합니다.

## 결과 (Consequences)

* **장점:** SQL 쿼리 작성 시간을 줄여 비즈니스 로직(마크다운 동기화, 암호화 등)에 더 집중할 수 있습니다. UI 레이어에서 데이터 변경을 관찰하기가 매우 쉬워집니다.
* **단점:** Realm 라이브러리 추가로 인해 앱 바이너리 크기(APK Size)가 약간 증가합니다. 또한, Realm 객체는 생성된 스레드에서만 접근 가능하므로 스레드 간 데이터 전달 시 주의가 필요합니다.

---

